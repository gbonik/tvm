def build_image(image_name) {
  hash = sh(
    returnStdout: true,
    script: 'git log -1 --format=\'%h\''
  ).trim()
  image_name = sh(
    returnStdout: true,
    script: "docker/sanitize-docker-image-name.sh ${image_name}",
    label: "Sanitize docker image name"
  ).trim()
  def image_version = sh(
    returnStdout: true,
    script: "docker/sanitize-docker-image-name.sh ${env.BRANCH_NAME}-${hash}-${env.BUILD_NUMBER}",
    label: "Sanitize docker image name"
  ).trim()
  def full_name = "${image_name}:${image_version}"
  sh(
    script: "${docker_build} ${image_name} --spec ${full_name}",
    label: 'Build docker image'
  )
  aws_account_id = sh(
    returnStdout: true,
    script: 'aws sts get-caller-identity | grep Account | cut -f4 -d\\"',
    label: 'Get AWS ID'
  ).trim()

  try {
    // Use a credential so Jenkins knows to scrub the AWS account ID which is nice
    // (but so we don't have to rely it being hardcoded in Jenkins)
    withCredentials([string(
      credentialsId: 'aws-account-id',
      variable: '_ACCOUNT_ID_DO_NOT_USE',
      )]) {
      withEnv([
        "AWS_ACCOUNT_ID=${aws_account_id}",
        'AWS_DEFAULT_REGION=us-west-2']) {
        sh(
          script: '''
            set -x
            aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
          ''',
          label: 'Log in to ECR'
        )
        def uploaded_name = "\$AWS_ACCOUNT_ID.dkr.ecr.\$AWS_DEFAULT_REGION.amazonaws.com/${full_name}"
        sh(
          script: """
            set -x
            docker tag ${full_name} ${uploaded_name}
            docker push ${uploaded_name}
          """,
          label: 'Upload image to ECR'
        )
        return uploaded_name;
      }
    }
  } finally {
    sh(
      script: 'rm -f ~/.docker/config.json',
      label: 'Clean up login credentials'
    )
  }
  sh(
    script: "docker rmi ${full_name}",
    label: 'Remove docker image'
  )
}

def build_docker_images() {
  stage('Docker Image Build') {
    // TODO in a follow up PR: Find ecr tag and use in subsequent builds
    parallel 'ci-lint': {
      node('CPU') {
        timeout(time: max_time, unit: 'MINUTES') {
          docker_init('none')
          init_git()
          ci_lint = build_image('ci_lint')
        }
      }
    }, 'ci-cpu': {
      node('CPU') {
        timeout(time: max_time, unit: 'MINUTES') {
          docker_init('none')
          init_git()
          ci_cpu = build_image('ci_cpu')
        }
      }
    }, 'ci-gpu': {
      node('GPU') {
        timeout(time: max_time, unit: 'MINUTES') {
          docker_init('none')
          init_git()
          ci_gpu = build_image('ci_gpu')
        }
      }
    }, 'ci-qemu': {
      node('CPU') {
        timeout(time: max_time, unit: 'MINUTES') {
          docker_init('none')
          init_git()
          ci_qemu = build_image('ci_qemu')
        }
      }
    }, 'ci-i386': {
      node('CPU') {
        timeout(time: max_time, unit: 'MINUTES') {
          docker_init('none')
          init_git()
          ci_i386 = build_image('ci_i386')
        }
      }
    }, 'ci-arm': {
      node('ARM') {
        timeout(time: max_time, unit: 'MINUTES') {
          docker_init('none')
          init_git()
          ci_arm = build_image('ci_arm')
        }
      }
    }, 'ci-wasm': {
      node('CPU') {
        timeout(time: max_time, unit: 'MINUTES') {
          docker_init('none')
          init_git()
          ci_wasm = build_image('ci_wasm')
        }
      }
    }, 'ci-hexagon': {
      node('CPU') {
        timeout(time: max_time, unit: 'MINUTES') {
          docker_init('none')
          init_git()
          ci_hexagon = build_image('ci_hexagon')
        }
      }
    }
  }
  // // TODO: Once we are able to use the built images, enable this step
  // // If the docker images changed, we need to run the image build before the lint
  // // can run since it requires a base docker image. Most of the time the images
  // // aren't build though so it's faster to use the same node that checks for
  // // docker changes to run the lint in the usual case.
  // stage('Sanity Check (re-run)') {
  //   timeout(time: max_time, unit: 'MINUTES') {
  //     node('CPU') {
  //       ws({{ m.per_exec_ws('tvm/sanity') }}) {
  //         init_git()
  //         sh (
  //           script: "${docker_run} ${ci_lint}  ./tests/scripts/task_lint.sh",
  //           label: 'Run lint',
  //         )
  //       }
  //     }
  //   }
  // }
}

def ecr_pull(full_name) {
  aws_account_id = sh(
    returnStdout: true,
    script: 'aws sts get-caller-identity | grep Account | cut -f4 -d\\"',
    label: 'Get AWS ID'
  ).trim()

  try {
    withEnv([
      "AWS_ACCOUNT_ID=${aws_account_id}",
      'AWS_DEFAULT_REGION={{ aws_default_region }}',
      "AWS_ECR_REPO=${aws_account_id}.{{ aws_ecr_url }}"]) {
      sh(
        script: '''
          set -eux
          aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ECR_REPO
        ''',
        label: 'Log in to ECR'
      )
      sh(
        script: """
          set -eux
          docker pull ${full_name}
        """,
        label: 'Pull image from ECR'
      )
    }
  } finally {
    withEnv([
      "AWS_ACCOUNT_ID=${aws_account_id}",
      'AWS_DEFAULT_REGION={{ aws_default_region }}',
      "AWS_ECR_REPO=${aws_account_id}.{{ aws_ecr_url }}"]) {
      sh(
        script: 'docker logout $AWS_ECR_REPO',
        label: 'Clean up login credentials'
      )
    }
  }
}

def docker_init(image) {
  sh(
    script: """
    set -eux
    docker image ls --all
    IMAGES=\$(docker image ls --all --format {% raw %}'{{.Repository}}:{{.Tag}}  {{.ID}}'{% endraw %})

    echo -e "Found images:\\n\$IMAGES"
    echo "\$IMAGES" | { grep -vE '${image}' || test \$? = 1; } | { xargs docker rmi || test \$? = 123; }

    docker image ls --all
    """,
    label: 'Clean old Docker images',
  )
  if (image.contains("amazonaws.com")) {
    // If this string is in the image name it's from ECR and needs to be pulled
    // with the right credentials
    ecr_pull(image)
  } else {
    sh(
      script: "docker pull ${image}",
      label: 'Pull docker image',
    )
  }
}

// Run make. First try to do an incremental make from a previous workspace in hope to
// accelerate the compilation. If something is wrong, clean the workspace and then
// build from scratch.
def make(docker_type, path, make_flag) {
  timeout(time: max_time, unit: 'MINUTES') {
    try {
      cmake_build(docker_type, path, make_flag)
      // always run cpp test when build
    } catch (hudson.AbortException ae) {
      // script exited due to user abort, directly throw instead of retry
      if (ae.getMessage().contains('script returned exit code 143')) {
        throw ae
      }
      echo 'Incremental compilation failed. Fall back to build from scratch'
      sh (
        script: "${docker_run} ${docker_type} ./tests/scripts/task_clean.sh ${path}",
        label: 'Clear old cmake workspace',
      )
      cmake_build(docker_type, path, make_flag)
    }
  }
}
